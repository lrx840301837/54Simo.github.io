{"meta":{"title":"CN_Simo","subtitle":null,"description":"我是一个小小的程序员，每天都在为许许多多的bug而奋斗，这里也是我的劳动成果！如果你我志同道合，希望多多交流！","author":"CN_Simo","url":"http://cnsimo.cn"},"pages":[{"title":"404","date":"2016-01-08T06:51:00.000Z","updated":"2017-02-04T09:22:06.633Z","comments":true,"path":"404.html","permalink":"http://cnsimo.cn/404.html","excerpt":"","text":"公益404页面 // Simo的技术博客"},{"title":"","date":"2017-02-01T18:15:34.000Z","updated":"2017-02-07T13:18:19.005Z","comments":true,"path":"about/index.html","permalink":"http://cnsimo.cn/about/index.html","excerpt":"","text":"关于我90后，暂住石家庄，就学于石家庄铁道大学网络工程专业，喜爱计算机，热爱科学。 关于博客作者网名：CN_Simo创建时间：2017.2.1目的：与博客园主页联合写博，记录学习中的一点一滴。 联系方式qq：2020745751邮箱：2020745751@qq.com微信号：simoGarden博客园主页：http://www.cnblogs.com/lxmwb 声明该博客为个人博客，所发表观点均为个人观点，与组织无关。博客内容均为原创，转载需和作者沟通（联系方式如上）并注明出处。博客创作遵从: by-nc-sa。有需求请下方留言！ 建站日志20170201新建页面。20170202新建分类、标签页，侧边栏增加友情链接。导航栏和侧边栏增加High一下。20170203首页添加boll动画，github与coding.Net共同托管，以及绑定了阿里云顶级域名cnsimo.cn20170204博客增设密码保护功能，例如 Hello World。20170207网站更新Awesome图标库，最新版本4.7.0。 BUG页面打开速度较慢；手机页面太low；每篇文章的关键字，总是被网站关键字替代；（已解决）当鼠标悬浮在“微信打赏二维码”上，“微信打赏”四个字抖动问题；（已解决）导航栏取消“标签”选项，则侧边栏标签项无法点击；（已解决）当通过“评论回复提示”链接进入加密的文章时，密码输入错误也可以顺利进入文章，较麻烦； 注：本博客为博主辛苦劳动的产物，请大家好好爱护它！"},{"title":"categories","date":"2017-02-02T12:19:23.000Z","updated":"2017-02-02T12:20:39.336Z","comments":true,"path":"categories/index.html","permalink":"http://cnsimo.cn/categories/index.html","excerpt":"","text":""},{"title":"最近访客","date":"2017-02-04T18:03:17.000Z","updated":"2017-02-04T18:14:49.283Z","comments":false,"path":"recent/index.html","permalink":"http://cnsimo.cn/recent/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-02T12:18:43.000Z","updated":"2017-02-02T12:21:02.497Z","comments":true,"path":"tags/index.html","permalink":"http://cnsimo.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Google Nexus虚拟设备打不开","slug":"Google Nexus虚拟设备打不开","date":"2017-03-06T05:32:45.000Z","updated":"2017-03-06T05:36:36.371Z","comments":true,"path":"2017-03-06/Google Nexus虚拟设备打不开/","link":"","permalink":"http://cnsimo.cn/2017-03-06/Google Nexus虚拟设备打不开/","excerpt":"情况：The configured driver wasn’t found. Either the necessary driver modules wasn’t loaded, the name was misspelled, or it was a misconfiguration. (VERR_PDM_DRIVER_NOT_FOUND).返回 代码:E_FAIL (0x80004005)组件:ConsoleWrap界面:IConsole {872da645-4a9b-1727-bee2-5585105b9eed}","text":"情况：The configured driver wasn’t found. Either the necessary driver modules wasn’t loaded, the name was misspelled, or it was a misconfiguration. (VERR_PDM_DRIVER_NOT_FOUND).返回 代码:E_FAIL (0x80004005)组件:ConsoleWrap界面:IConsole {872da645-4a9b-1727-bee2-5585105b9eed} 解决办法： 检查虚拟机设置的位数是否与本机位数兼容 打开VirtualBox——设置——声音——选择虚空音驱动，确定即可","categories":[{"name":"Android开发","slug":"Android开发","permalink":"http://cnsimo.cn/categories/Android开发/"}],"tags":[]},{"title":"Qt入门之基础篇（三）：掌握Qt4的静态编译基本方法","slug":"Qt入门之基础篇（三）：掌握Qt4的静态编译基本方法","date":"2017-02-25T11:56:00.000Z","updated":"2017-02-28T13:44:18.721Z","comments":true,"path":"2017-02-25/Qt入门之基础篇（三）：掌握Qt4的静态编译基本方法/","link":"","permalink":"http://cnsimo.cn/2017-02-25/Qt入门之基础篇（三）：掌握Qt4的静态编译基本方法/","excerpt":"转载载请注明出处：CN_Simo. 1.导语：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前两章都提到过“静态编译”（Static Compilation），在Windows下一次静态编译差不多需要长达三个小时才能完成，而且还非常容易由于各种原因而出错。那么为什么要花这时间去干这件事情呢！我当初只是想用Qt做一个exe贺卡发给同学，但是通常情况下，我们做出的exe需要各种dll动态链接文件才能正常运行（压缩打包给别人？直接发送一个exe文件都懒得打开，更何况还需要解压呢），那么我就想能不能只需要一个exe就可以呢。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“静态编译”的作用正是让exe脱离dll的束缚，但是同时你的exe可能比之前要大好几倍（没办法，万物都无绝对完美）。前言说到这里，我们就进入正文来： 2.文章思路： 准备编译所需环境及文件； 编译Qt4.8.6源码；（此过程或许要花掉你一上午的时间，要有良好的心理素质哦！） 配置Qt静态库到Qt Creator； 静态模式重新编译Hello World程序； 找到exe程序与之前版本进行大小对比； 总结说明。","text":"转载载请注明出处：CN_Simo. 1.导语：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;前两章都提到过“静态编译”（Static Compilation），在Windows下一次静态编译差不多需要长达三个小时才能完成，而且还非常容易由于各种原因而出错。那么为什么要花这时间去干这件事情呢！我当初只是想用Qt做一个exe贺卡发给同学，但是通常情况下，我们做出的exe需要各种dll动态链接文件才能正常运行（压缩打包给别人？直接发送一个exe文件都懒得打开，更何况还需要解压呢），那么我就想能不能只需要一个exe就可以呢。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;“静态编译”的作用正是让exe脱离dll的束缚，但是同时你的exe可能比之前要大好几倍（没办法，万物都无绝对完美）。前言说到这里，我们就进入正文来： 2.文章思路： 准备编译所需环境及文件； 编译Qt4.8.6源码；（此过程或许要花掉你一上午的时间，要有良好的心理素质哦！） 配置Qt静态库到Qt Creator； 静态模式重新编译Hello World程序； 找到exe程序与之前版本进行大小对比； 总结说明。 3.Let‘s start： 3.1.编译准备：3.1.1.所需环境：配置当然是越好越快了，我的配置编译了一上午 3.1.2.所需文件 qt-everywhere-opensource-src-4.8.6.zip 教程一中安装好的Qt（版本4或5都可） 3.2.前期工作：步骤一：配置编译文件qmake.conf我将zip解压到E盘，qmake.conf文件就在源码目录\\mkspecs\\win32-g++中，用记事本打开修改下列参数：QMAKE_LFLAGS和QMAKE_LFLAGS_DLL。参数值为 -static，如下图：修改完之后，我在E盘新建一个“qt4.8.6_static”文件夹作为编译输出目录，并且需要将更改后的“mkspecs”文件夹复制到qt4.8.6_static文件夹中。若不做此操作步骤三可能会报错，类似下面这样：12Could not find mkspecs for your QMAKESPEC(win32-g++) after trying:E:/qt/qt4.8.6_static\\mkspecs 步骤二：设置环境变量以及所需编译内容开始菜单中打开Qt命令窗口，cd命令进入源码目录：1e:&amp;cd e:\\qt-everywhere-opensource-src-4.8.6 下面所有操作都在本目录中进行。输入以下两条命令：12set QMAKESPEC=win32-g++configure -confirm-license -opensource -prefix “F:\\Qt\\Qt_4.8.6_static” -debug-and-release -static -platform win32-g++ -nomake demos -nomake examples -nomake tests -fast -mp set命令设置环境变量（注意：窗口关闭将清空设置，需重新设置） configure命令配置编译内容，参数说明： 回车后，看到以下信息代表完成： 3.3.开始编译：1mingw32-make 输入命令开始编译，此过程最易出错，因为持续时间长，中间可能遇到很多自己解决不了的问题，此时只能是重新开始。如果过程中未出错的话可能需要3个小时以上才能结束（我的电脑配置见上），你可以去做别的事情了，在编译过程中最好不要用电脑去做其他占用大量系统资源的事情，因为这么做将会大大增加失败的几率。 3.4.编译结束：结束之后，输入下面命令开始一大堆的复制命令，这时你可以看到qt4.8.6_static目录已经开始急剧膨胀了。1mingw32-make install 大概15分钟即可复制完毕。要注意，如果移动或者更名qt4.8.6_static目录，将导致bin目录中的程序异常，下面操作可解决此问题：在bin目录下创建一个qt.conf文件，内容这么写：12[paths]Prefix = .. 如此，便可进行移动或更名操作了。 3.5.配置Qt Creator：打开qt creator，【工具】-【选项】-【构建和运行】，在里面添加刚编译出的qt4.8.6静态版本（qmake路径选择bin目录中的qmake.exe哦），之后添加新的构建套件，qt版本选择qt4.8.6，名称随意，如下图： 3.6.Hello World测试：【新建】一个project，构建套件选择刚刚添加的。在这里，我续用教程二中的helloworld项目测试一下。打开helloworld项目后，crlt+5将新的构建套件添加上去，点击左下角【部署构建套件】按钮分别选择原有Kit和静态版Kit的release版本运行项目，几秒钟后即可看到helloworld运行界面： 3.7.exe文件对比：寻找exe生成目录，找到两个exe文件，惊奇的发现了这个结果：（右面是由我们的qt静态库编译生成的程序，左面则是原来的） 结果显示： 同样是release版本的，所产生的helloworld程序大小完全不在一个等级（一个KB级别，一个MB级别），静态编译败； 动态编译出的exe文件想要打开需要dll动态链接文件的支持，静态链接编译出的exe文件则可以直接打开，不再需要dll文件的束缚，静态编译胜； 4.总结说明： 通过上面结果可以看出：动态编译和静态编译都有各自优缺点，我们应该适当选择自己所需；qt源码编译的过层拖得越长越是容易出错误，选择一台配置好点的电脑可以适当增加编译速度；通过本章知识，我们的内心或许会嫌麻烦又或许会觉得很有趣，如果你是后者希望以后的学习你能够越来越出色。让我们一起期待下期内容吧[@CN_Simo]! 5.结束：上一篇：Qt入门之基础篇（二）：Qt项目建立、编译、运行和发布过程解析","categories":[{"name":"Qt框架","slug":"Qt框架","permalink":"http://cnsimo.cn/categories/Qt框架/"}],"tags":[{"name":"Qt入门之基础篇","slug":"Qt入门之基础篇","permalink":"http://cnsimo.cn/tags/Qt入门之基础篇/"}]},{"title":"Java Web连接Mysql的通用类代码","slug":"Java Web连接Mysql数据库的通用类代码","date":"2017-02-24T13:00:51.000Z","updated":"2017-02-24T13:01:11.992Z","comments":true,"path":"2017-02-24/Java Web连接Mysql数据库的通用类代码/","link":"","permalink":"http://cnsimo.cn/2017-02-24/Java Web连接Mysql数据库的通用类代码/","excerpt":"使用情况：当多个文件中用到连接数据库操作时，如果写多次操作代码将显得愚笨。这里的这个类DBHelper，只需要在用到连接数据库操作的时候导入这个类包，然后通过这个类可以很容易的实现连接数据库操作。","text":"使用情况：当多个文件中用到连接数据库操作时，如果写多次操作代码将显得愚笨。这里的这个类DBHelper，只需要在用到连接数据库操作的时候导入这个类包，然后通过这个类可以很容易的实现连接数据库操作。 类代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567package DBHelper;import java.io.Console;import java.sql.*;import java.util.Enumeration;//import java.util.logging.*;//import javax.swing.table.*;/** * SQL 基本操作 * 通过它,可以很轻松的使用 JDBC 来操纵数据库 * @author Null */public class DBHelper&#123; /** * 驱动 */ //public static String driver = \"com.microsoft.jdbc.sqlserver.SQLServerDriver\"; public static String driver = \"com.mysql.jdbc.Driver\"; /** * 连接字符串 */ //public static String url = \"jdbc:microsoft:sqlserver://127.0.0.1:1433;DatabaseName=st\"; public static String url = \"jdbc:mysql://127.0.0.1:3306/test\"; /** * 用户名 */ public static String user = \"root\"; /** * 密码 */ public static String password = \"root\"; /** * 不允许实例化该类 */ private DBHelper() &#123; &#125; /** * 获取一个数据库连接 * 通过设置类的 driver / url / user / password 这四个静态变量来 设置数据库连接属性 * @return 数据库连接 */ public static Connection getConnection() &#123; try &#123; //获取驱动 Class.forName(driver); &#125; catch (ClassNotFoundException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); &#125; try &#123; return DriverManager.getConnection(url, user, password); &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); return null; &#125; &#125; /** * 获取一个 Statement * 该 Statement 已经设置数据集 可以滚动,可以更新 * @return 如果获取失败将返回 null,调用时记得检查返回值 */ public static Statement getStatement() &#123; Connection conn = getConnection(); if (conn == null) &#123; return null; &#125; try &#123; return conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE); // 鐠佸墽鐤嗛弫鐗堝祦闂嗗棗褰叉禒銉︾泊閸旓拷閸欘垯浜掗弴瀛樻煀 &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); close(conn); &#125; return null; &#125; /** * 获取一个 Statement * 该 Statement 已经设置数据集 可以滚动,可以更新 * @param conn 数据库连接 * @return 如果获取失败将返回 null,调用时记得检查返回值 */ public static Statement getStatement(Connection conn) &#123; if (conn == null) &#123; return null; &#125; try &#123; return conn.createStatement(ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE); // 设置数据集可以滚动,可以更新 &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); return null; &#125; &#125; /** * 获取一个带参数的 PreparedStatement * 该 PreparedStatement 已经设置数据集 可以滚动,可以更新 * @param cmdText 需要 ? 参数的 SQL 语句 * @param cmdParams SQL 语句的参数表 * @return 如果获取失败将返回 null,调用时记得检查返回值 */ public static PreparedStatement getPreparedStatement(String cmdText, Object[] cmdParams) &#123; Connection conn = getConnection(); if (conn == null) &#123; return null; &#125; PreparedStatement pstmt = null; try &#123; pstmt = conn.prepareStatement(cmdText, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE); int i = 1; for (Object item : cmdParams) //java foreach遍历集合,要求集合类实现Enumeration接口 &#123; pstmt.setObject(i, item); i++; &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); close(conn); &#125; return pstmt; &#125; /** * 获取一个带参数的 PreparedStatement * 该 PreparedStatement 已经设置数据集 可以滚动,可以更新 * @param conn 数据库连接 * @param cmdText 需要 ? 参数的 SQL 语句 * @param cmdParams SQL 语句的参数表 * @return 如果获取失败将返回 null,调用时记得检查返回值 */ public static PreparedStatement getPreparedStatement(Connection conn, String cmdText, Object[] cmdParams) &#123; if (conn == null) &#123; return null; &#125; PreparedStatement pstmt = null; try &#123; pstmt = conn.prepareStatement(cmdText, ResultSet.TYPE_SCROLL_SENSITIVE, ResultSet.CONCUR_UPDATABLE); int i = 1; for (Object item : cmdParams) &#123; pstmt.setObject(i, item); i++; &#125; &#125; catch (SQLException ex) &#123; System.out.println(ex.getMessage()); //ex.printStackTrace(); close(pstmt); &#125; return pstmt; &#125; /** * 执行 SQL 语句,返回结果为整型 * 主要用于执行非查询语句 * @param cmdText SQL 语句 * @return 非负数:正常执行; -1:执行错误; -2:连接错误 */ public static int ExecSql(String cmdText) &#123; Statement stmt = getStatement(); if (stmt == null) &#123; return -2; &#125; int i; try &#123; i = stmt.executeUpdate(cmdText); &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null,ex); System.out.println(ex.getMessage()); i = -1; &#125; closeConnection(stmt); return i; &#125; /** * 执行 SQL 语句,返回结果为整型 * 主要用于执行非查询语句 * @param cmdText SQL 语句 * @return 非负数:正常执行; -1:执行错误; -2:连接错误 */ public static int ExecSql(Connection conn, String cmdText) &#123; Statement stmt = getStatement(conn); if (stmt == null) &#123; return -2; &#125; int i; try &#123; i = stmt.executeUpdate(cmdText); &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); i = -1; &#125; close(stmt); return i; &#125; /** * 执行 SQL 语句,返回结果为整型 * 主要用于执行非查询语句 * @param cmdText 需要 ? 参数的 SQL 语句 * @param cmdParams SQL 语句的参数表 * @return 非负数:正常执行; -1:执行错误; -2:连接错误 */ //非常好用 public static int ExecSql(String cmdText, Object[] cmdParams) &#123; PreparedStatement pstmt = getPreparedStatement(cmdText, cmdParams); if (pstmt == null) &#123; return -2; &#125; int i; try &#123; i = pstmt.executeUpdate(); &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); i = -1; &#125; closeConnection(pstmt); return i; &#125; /** * 执行 SQL 语句,返回结果为整型 * 主要用于执行非查询语句 * @param conn 数据库连接 * @param cmdText 需要 ? 参数的 SQL 语句 * @param cmdParams SQL 语句的参数表 * @return 非负数:正常执行; -1:执行错误; -2:连接错误 */ public static int ExecSql(Connection conn, String cmdText, Object[] cmdParams) &#123; PreparedStatement pstmt = getPreparedStatement(conn, cmdText, cmdParams); if (pstmt == null) &#123; return -2; &#125; int i; try &#123; i = pstmt.executeUpdate(); &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); i = -1; &#125; close(pstmt); return i; &#125; /** * 返回结果集的第一行的一列的值,其他忽略 * @param cmdText SQL 语句 * @return */ public static Object ExecScalar(String cmdText) &#123; ResultSet rs = getResultSet(cmdText); Object obj = getScalar(rs); closeConnection(rs); return obj; &#125; /** * 返回结果集的第一行的一列的值,其他忽略 * @param conn 数据库连接 * @param cmdText SQL 语句 * @return */ public static Object ExecScalar(Connection conn, String cmdText) &#123; ResultSet rs = getResultSet(conn, cmdText); Object obj = getScalar(rs); closeEx(rs); return obj; &#125; /** * 返回结果集的第一行的一列的值,其他忽略 * @param cmdText 需要 ? 参数的 SQL 语句 * @param cmdParams SQL 语句的参数表 * @return */ public static Object ExecScalar(String cmdText, Object[] cmdParams) &#123; ResultSet rs = getResultSet(cmdText, cmdParams); Object obj = getScalar(rs); closeConnection(rs); return obj; &#125; /** * 返回结果集的第一行的一列的值,其他忽略 * @param conn 数据库连接 * @param cmdText 需要 ? 参数的 SQL 语句 * @param cmdParams SQL 语句的参数表 * @return */ public static Object ExecScalar(Connection conn, String cmdText, Object[] cmdParams) &#123; ResultSet rs = getResultSet(conn, cmdText, cmdParams); Object obj = getScalar(rs); closeEx(rs); return obj; &#125; /** * 返回一个 ResultSet * @param cmdText SQL 语句 * @return */ public static ResultSet getResultSet(String cmdText) &#123; Statement stmt = getStatement(); if (stmt == null) &#123; return null; &#125; try &#123; return stmt.executeQuery(cmdText); &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); closeConnection(stmt); &#125; return null; &#125; /** * 返回一个 ResultSet * @param conn * @param cmdText SQL 语句 * @return */ public static ResultSet getResultSet(Connection conn, String cmdText) &#123; Statement stmt = getStatement(conn); if (stmt == null) &#123; return null; &#125; try &#123; return stmt.executeQuery(cmdText); &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); close(stmt); &#125; return null; &#125; /** * 返回一个 ResultSet * @param cmdText 需要 ? 参数的 SQL 语句 * @param cmdParams SQL 语句的参数表 * @return */ public static ResultSet getResultSet(String cmdText, Object[] cmdParams) &#123; PreparedStatement pstmt = getPreparedStatement(cmdText, cmdParams); if (pstmt == null) &#123; return null; &#125; try &#123; return pstmt.executeQuery(); &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); closeConnection(pstmt); &#125; return null; &#125; /** * 返回一个 ResultSet * @param conn 数据库连接 * @param cmdText 需要 ? 参数的 SQL 语句 * @param cmdParams SQL 语句的参数表 * @return */ public static ResultSet getResultSet(Connection conn, String cmdText, Object[] cmdParams) &#123; PreparedStatement pstmt = getPreparedStatement(conn, cmdText, cmdParams); if (pstmt == null) &#123; return null; &#125; try &#123; return pstmt.executeQuery(); &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); close(pstmt); &#125; return null; &#125; public static Object getScalar(ResultSet rs) &#123; if (rs == null) &#123; return null; &#125; Object obj = null; try &#123; if (rs.next()) &#123; obj = rs.getObject(1); &#125; &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); &#125; return obj; &#125; private static void close(Object obj) &#123; if (obj == null) &#123; return; &#125; try &#123; if (obj instanceof Statement) &#123; ((Statement) obj).close(); &#125; else if (obj instanceof PreparedStatement) &#123; ((PreparedStatement) obj).close(); &#125; else if (obj instanceof ResultSet) &#123; ((ResultSet) obj).close(); &#125; else if (obj instanceof Connection) &#123; ((Connection) obj).close(); &#125; &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); &#125; &#125; private static void closeEx(Object obj) &#123; if (obj == null) &#123; return; &#125; try &#123; if (obj instanceof Statement) &#123; ((Statement) obj).close(); &#125; else if (obj instanceof PreparedStatement) &#123; ((PreparedStatement) obj).close(); &#125; else if (obj instanceof ResultSet) &#123; ((ResultSet) obj).getStatement().close(); &#125; else if (obj instanceof Connection) &#123; ((Connection) obj).close(); &#125; &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); &#125; &#125; private static void closeConnection(Object obj) &#123; if (obj == null) &#123; return; &#125; try &#123; if (obj instanceof Statement) &#123; ((Statement) obj).getConnection().close(); &#125; else if (obj instanceof PreparedStatement) &#123; ((PreparedStatement) obj).getConnection().close(); &#125; else if (obj instanceof ResultSet) &#123; ((ResultSet) obj).getStatement().getConnection().close(); &#125; else if (obj instanceof Connection) &#123; ((Connection) obj).close(); &#125; &#125; catch (SQLException ex) &#123; //Logger.getLogger(DBHelper.class.getName()).log(Level.SEVERE, null, ex); System.out.println(ex.getMessage()); &#125; &#125;&#125; 例子sjp文件内容：1234567891011121314151617181920212223&lt;%@ page language=\"java\" import=\"java.util.*,java.sql.*,DBHelper.*\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\"&gt; &lt;/head&gt; &lt;body&gt; &lt;% String SQL=\"SELECT * FROM user WHERE userName=? AND password=?\"; String uid=request.getParameter(\"uid\"); String pwd=request.getParameter(\"pwd\"); Object[] params=new Object[]&#123;uid,pwd&#125;; ResultSet rs=DBHelper.getResultSet(SQL,params); if(rs.next()) out.print(\"登录成功\"); else out.print(\"登录失败\"); rs.close(); %&gt; &lt;/body&gt;&lt;/html&gt;","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://cnsimo.cn/categories/Java-Web/"}],"tags":[]},{"title":"eclipse：The import XXX cannot be resolved","slug":"The import XXX cannot be resolved【eclipse】","date":"2017-02-24T12:16:32.000Z","updated":"2017-02-24T12:29:01.077Z","comments":true,"path":"2017-02-24/The import XXX cannot be resolved【eclipse】/","link":"","permalink":"http://cnsimo.cn/2017-02-24/The import XXX cannot be resolved【eclipse】/","excerpt":"问题背景：将某个Java Web项目导入到另一台PC上时，有可能会产生此错误，很明显的情况是String下标记为波浪线。 产生原因：项目所用的原JRE与现JRE不同造成，重新配置一下JRE即可！","text":"问题背景：将某个Java Web项目导入到另一台PC上时，有可能会产生此错误，很明显的情况是String下标记为波浪线。 产生原因：项目所用的原JRE与现JRE不同造成，重新配置一下JRE即可！ 解决方法： 右键项目—-buildpath——-configura buildpath; 选择libraries选项卡找到打×的选项，即包含“JRE”字串的条目； 选中此条目，右侧点击“edit”； 选择本地JRE； 回到代码中，发现所有的波浪线都已消失。","categories":[{"name":"Java Web","slug":"Java-Web","permalink":"http://cnsimo.cn/categories/Java-Web/"}],"tags":[]},{"title":"win10网络适配器属性界面空白","slug":"win10网络适配器属性界面空白","date":"2017-02-24T11:47:19.000Z","updated":"2017-02-24T12:28:45.573Z","comments":true,"path":"2017-02-24/win10网络适配器属性界面空白/","link":"","permalink":"http://cnsimo.cn/2017-02-24/win10网络适配器属性界面空白/","excerpt":"原因：network setup services服务未启动。 解决方法：通过win+R运行“services.msc”，可打开 服务 窗口，找到network setup service服务启动即可！","text":"原因：network setup services服务未启动。 解决方法：通过win+R运行“services.msc”，可打开 服务 窗口，找到network setup service服务启动即可！ 问题延伸：可能我们很多比这个情况更加严重：network setup service服务根本启动不了，也不能这么说，应该是刚启动，然后没2s钟这个服务就又自动关闭了，这可如何是好，试试重装驱动吧，结果还是这样，下面就让我们看看解决方法。 这么做：只要在服务启动的那两秒钟之内（服务未关闭的时间段），打开网络适配器的属性框。会发现不再是空白了，而且nss服务不再自动关闭了。如果未成功，那就多试几次吧。造成这种情况的原因可能是软硬件之间有冲突，猜测的。","categories":[{"name":"windows","slug":"windows","permalink":"http://cnsimo.cn/categories/windows/"}],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2017-02-04T08:50:04.000Z","updated":"2017-02-04T15:00:17.331Z","comments":true,"path":"2017-02-04/hello-world/","link":"","permalink":"http://cnsimo.cn/2017-02-04/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"Hexo官方文档","slug":"Hexo官方文档","permalink":"http://cnsimo.cn/categories/Hexo官方文档/"}],"tags":[]},{"title":"Qt Quick编程(1)——QML的核心部分ECMAScript","slug":"Qt Quick编程(1)——QML的核心部分ECMAScript","date":"2017-01-18T16:24:00.000Z","updated":"2017-02-05T09:45:02.936Z","comments":true,"path":"2017-01-19/Qt Quick编程(1)——QML的核心部分ECMAScript/","link":"","permalink":"http://cnsimo.cn/2017-01-19/Qt Quick编程(1)——QML的核心部分ECMAScript/","excerpt":"","text":"说道QML，不得不先说一下ECMAScript： ECMAScript语言的标准是由Netscape、Sun、微软、Borland等公司基于JavaScript和JScript锤炼、定义出来的。 ECMAScript可以为不同种类的宿主环境提供核心的脚本编程能力。ECMAScript仅仅是一个描述，定义了脚本语言的所有属性、方法和对象。它描述了一下内容： 语法 类型 语句 关键字 保留字 运算符 对象 其他语言可以以它为基础拓展出新特性，比如QML引入了Qt对象系统中的信号与槽等特色功能。 QML有三个核心： ECMAScript Qt对象系统 Qt Quick标准库 所以说学号QML，了解ECMAScript必不可少。在开始了解ECMAScript的基本特性之前，要知道qmlscene可以加载QML文档以达到测试的目的，比如如下测试代码，就可以在Qt命令行界面中以“qmlscene text.qml”的方式显示界面效果： 123456789/* * text.qml */import QtQuick 2.2Rectangle &#123; Component.onCompleted: &#123; // 这里放测试代码 &#125;&#125; 下面开始简单介绍ECMAScript： 1.语法与C、C++或者Java类似。如果你有这几种语言的基础，那学习ECMAScript简直就是“张飞吃豆芽，小菜一碟”。需要注意的几点是： 区分大小写知道变量area和Area不一样就行了，无需多言。 弱类型ECMAScript语言是弱类型语言，变量没有特定的类型，在定义变量的时候都用var定义，可以用任意值初始化变量，而且可以随时改变变量所存储的数据类型，当然了，最好是不要这么做。 分号可写可不写ECMAScript中，如果没有以分号结尾，它就会把本行的末尾当做是该语句的结束。之后需要QML与C++混合编程，为了不思想分裂，故而还是与c++风格保持一致的好啊，你说是也不是。 2.变量与c++中变量声明以及定义是类似的，这里不必多言。在ECMAScript中，变量可以存放两种类型的值，即原始值和引用值。原始值一般存放在栈上，引用值是一个指针，指向存储在堆中的对象，如果你熟悉c++的话，那么很容易就能理解这个概念。 3.原始类型在ECMAScript中，原始类型有5种： Undefined Null Boolean Number String typeof运算符可以判断一个值的类型，是原始类型会返回类型的名字，是引用类型则统一返回“object”作为类型名字。以下为简单的示例： 1234567891011/* * typeof value */import QtQuick 2.2Rectangle &#123; Component.onCompleted: &#123; var name = \"matao\"; console.log(typeof name); console.log(typeof 60); &#125;&#125; Undefined类型和Null类型都只有一个值，即undefined、null。 数字类型的最大值是Number.MAX_VALUE，最小值是Number.MIN_VALUE，它们定义了Number值的外边界，所有的ECMAScript数都必须在这两个值之间。不过，由表达式的值可以不落在这两个数之间。大于最大值，它将被赋值为Number.POSITIVE_INFINITY，即正无穷大；当生成的数值小于Number.MIN_VALUE时，将被赋值为Number.NEGATIVE_INFINITY，即负无穷大。其实，ECMAScript也有专门表示无穷大的值，即Infinity，而-Infinity表示负无穷大。 isFinit()方法可以判断一个数是否是又穷的。 还有一个特殊值NaN，表示非数。isNaN判断一个数是否是非数。 4.类型转换 toString()Boolean、Number、String三种原始类型，都有toString()方法，可以把它们的值变为字符串； parseInt()和parseFloat()这两种方法只适用于String类型，而且只转换无效字符之前的部分，见如下示例： 1234parseInt(\"2014年\"); //2014parseInt(\"3.14\"); //3parseFloat(\"3.13.1\"); //3.13parseInt(\"INGI\"); //NaN 强制类型转换 Boolean(value)value是非空字符串、非0数字或对象时，Boolean()返回true；value是空字符串、0、undefined或null，Boolean()返回false； Number(value)Number()转换的是整个值！ 这是与parseInt()和parseFloat()不同的地方。 String(value)它与调用tostring()方法的唯一不同在于：对null或undefined值强制类型转换可以生成字符串而不发生错误： 123var null2String = String(null); // “null”var oNull = nullvar s2 = oNull.toString(); // error 5.对象首先声明，其实在ECMAScript中并没有“类”这个词，与其对应的是“对象定义”，这里的“类”代指的就是这个意思，区别于C++、Java中的类。前面提到的引用值，指向的就是对象。 对象是由new运算符加上要实例化的类型的名字创建的。比如：1var a = new Array(); 如果类的构造函数没有参数，括号可以省略。 几个基本的对象： Object Object类是所有ECMAScript类的基类，Object类的所有属性和方法都会出现在其他类中： Object类中的属性： constructor，指向创建对象的函数，对于Object类，它指向object()函数； prototype，对该对象的对象原型的引用； Object类中的方法： hasOwnProperty(property)，判断对象是否有某个属性，property为字符串； isPrototypeOf(object)，判断该对象是否为另一个对象的原型； propertyIsEnumerable(property)，判断给定的属性是否可以用for…in语句进行枚举（一般自定义的对象属性都是可以枚举的）； toString()，返回对象的字符串表示。 valueOf()，返回最适合该对象的原始值。对于许多类，该方法返回的值都与toString()一样。以上的每种属性和方法都可以被object的派生类覆盖。 关于对象有以下几点需要说明： 动态增加属性 在ECMAScript中，对象的属性可以动态地增删，比如下面的示例： 123var person = new Object();person.name = \"LingXiaoMo\";person.year = 20; 动态增加方法 对象的方法就是一个函数，也可以动态地增加，然后按函数的方式调用，比如下面的示例：1234person.printInfo = function printInfo() &#123; console.log(\"name-\" , this.name , \"year-\" , this.year);&#125;person.printInfo(); 使用数组下标访问属性和方法 对象的属性和方法居然可以使用数组下标的形式来访问。比如这样： 12console.log(person[\"name\"]); // -&gt;person.nameperson[\"printInfo\"](); // -&gt;person.printInfo() []中的东西叫“索引”，这里的索引是字符串，而不是我们常见的整数。是不是想到了Key-Value（键值对）？ 使用for…in枚举对象属性 前面我们提过propertyIsEnumerable()方法可以判断一个对象的属性是否可以枚举。多数自定义属性和方法都是可以枚举的，而内置对象或宿主对象的多数核心属性是不能枚举的。枚举对象属性时我们使用数组下标法访问对象属性。看如下的示例： 123for(var prop in person) &#123; console.log(prop,\",\",person[prop]);&#125; 对象的字面量表示法前面已经用过数字字面量、字符串字面量： 所有QML代码中直接输入的数字被看作是数字字面量； 字符串字面量可以用双引号（”）或单引号（’)来声明；其实对象也能用字面量表示：1234var person = &#123; \"name\": \"LingXiaoMo\", \"year\": 20&#125; 上面的代码和前面先构造Object再添加属性的方式，得到的是一样的对象。 对象的字面量表示法，语法是这样的：使用一对花括号表示一个对象，其属性以Key:Value对的形式放在其括号内，多个属性之间使用 逗号 分隔；如果一个属性本身是对象，还可以使用字面量表示法来嵌套描述。 StringString、Boolean、Numble都有自己的对象表示法，一般都使用原始值。 你可以这样构造一个String对象：1var str = new String(\"I\\'m a string\"); 对字符串有以下基本操作： 字符串长度 length属性返回字符串中的字符个数： 1console.log(str.length); 对于String的原始值，同样可以通过length属性获知字串长度。比如：1console.log(\"I\\'m a string\".length); 访问单个字符 charAt()方法可以访问指定索引位置的字符； 可以通过数组下标法访问指定位置的字符； 而charCodeAt()方法返回指定位置字符对应的Unicode编码; 下面是简单的示例： 123console.log(str.charAt(2)); // 输出mconsole.log(str[0]); // 输出Iconsole.log(str.charCodeAt(1)); // 输出39 查找字串 indexOf()方法从字符串的开头检索子串，lastInderOf()方法从字符串的结尾开始检索子串，它们返回子串在字符串中的位置，如果找不到则返回-1.这两个方法有一个可选参数，指定开始查找的位置； search()方法用于检索字符串中指定的字符串，或检索与正则表达式相匹配的子字符串。区分大小写，且只能从字符串的开始进行查找； match()方法可在字符串内检索指定的值，或者寻找匹配指定正则表达式的一个或多个子串。返回一个存放所有符合规则的子串的数组； 注： 上面4种方法都区分大小写。以一个忽略大小写的正则表达式为参数调用search()或match()方法，可实现忽略大小写的查找。 简单的示例： 1234567console.log(str.indexOf(\"ing\",4)); // 输出9console.log(str.search(/String/)); // 输出-1console.log(str.search(/String/i)); // 忽略大小写，输出6console.log(str.match(\"tri\")); // 输出[tri]var numberSource = new String(\"2014-08-18, I got 96\");var results = numberSource.match(/\\d+/g);console.log(results); // 输出[2014,08,18,96] 字符串比较使用大于(&gt;)、小于(&lt;)、等于(==)三个运算符比较字符串，使用的是字符的Unicode编码进行比较，忽略了与本地语言环境相关的语义和排序规则。localeCompare()方法在比较字符串时，默认采用底层操作系统提供的排序规则。等于时返回0，大于时返回1，小于时返回-1。 示例代码片段： 123456var str1 = \"Qt\";var str2 = \"qt\";var str3 = \"ok\";console.log(str1&lt;str2); // trueconsole.log(str1.localeCompare(str2)); // 1console.log(str3.localeCompare(str2)); // -1 可以看到第3行和第4行的结果不一致，真令人意外。 连接字符串 concat()方法用于连接两个或多个字符串，返回一个新的字符串。实际中，使用”+“号可能会更方便一些，效果一样。 提取子串 提取子串的方法有三个： slice(): 两个参数，第一个参数表示起始位置，第二个参数表示结束位置（截取的子串不包括此位置上字符）； substring(): 两个参数，与slice()类似，此方法总是把较小的参数作为起始位置，比如substring(1,3)和substring(3,1)效果一样； substr(): 两个参数，第一个参数表示其实位置，第二个表示待提取子串的长度； 注： 上述三个方法都可以不指定第二个参数，如不指定则返回从起始位置到结束的所有字符； slice()和substring()两个方法的不同之处在于对负数参数的处理：前者遇到负数时，会应用”从串尾倒数“这种策略，而后者则是把负数当作0来处理。 大小写转换 实现大小写转换的有四个方法： 大写-&gt;小写 toLowerCase() toLocaleLowerCase() 小写-&gt;大写 toUpperCase() toLocaleUpperCase() 字符串替换 replace方法可以实现这个功能。它的第一个参数是一个字符串原始值或者正则表达式，第二个参数是新字符串。 使用arg()进行值替换 arg()是Qt C++中的东西，在这里是QML对实现ECMAScript时做的扩充。 arg()的语法是：string arg(value)。其中value可以是数字、字符串、布尔值、对象等，它用于替换发出调用的字符串对象内的%1、%2、%N等占位符；布尔值会被替换为1或0；对于对象，则使用toString()方法转换后的结果来替换对应的占位符。arg()会返回一个新的字符串对象。 示例代码片段：12var expression = \"%1 &lt; %2 = %3\";var result = expression.arg(7).arg(8).arg(\"true\"); 需要注意的是，String类型的对象是只读的，凡是牵涉到修改的动作，母串本身不会改变。另外，字符串原始值是伪对象，它可以使用String类的所有属性和方法。 String类说到这里，不再多言。 RegExp在Qt C++中有QRegExp，在QML中有RegExp，它们是对字符串执行模式匹配的强大工具。 在ECMAScript中支持的两种构造正则表达式的方法： 字面量语法：/pattern/attributes 创建RegExp对象：new RegExp(pattern,attributes) ​ 或RegExp(pattern,attributes)。 关于正则表达式的修饰符、元字符等其他内容，这里暂且略过。 Array 在ECMAScript中数组都是动态的，其大小可以随时变化，而且数组中的元素类型可以不同。 下面我们来看看对数组的基本操作： 数组的创建123var arrayObj = new Array(); //创建一个数组var arrayObj = new Array([size]); //创建一个数组并指定长度，注意不是上限，是长度var arrayObj = new Array([element0[, element1[, ...[, elementN]]]]); //创建一个数组并赋值 要说明的是，虽然第二种方法创建数组指定了长度，但实际上所有情况下数组都是变长的，也就是说即使指定了长度为5，仍然可以将元素存储在规定长度以外的，注意：这时长度会随之改变。 数组的元素的访问 12var testGetArrValue=arrayObj[1]; //获取数组的元素值arrayObj[1]= \"这是新值\"; //给数组元素赋予新的值 数组元素的添加 123arrayObj. push([item1 [item2 [. . . [itemN ]]]]);// 将一个或多个新元素添加到数组结尾，并返回数组新长度 arrayObj.unshift([item1 [item2 [. . . [itemN ]]]]);// 将一个或多个新元素添加到数组开始，数组中的元素自动后移，返回数组新长度arrayObj.splice(insertPos,0,[item1[, item2[, . . . [,itemN]]]]);//将一个或多个新元素插入到数组的指定位置，插入位置的元素自动后移，返回\"\"。 数组元素的删除 123arrayObj.pop(); //移除最后一个元素并返回该元素值arrayObj.shift(); //移除最前一个元素并返回该元素值，数组中元素自动前移arrayObj.splice(deletePos,deleteCount); //删除从指定位置deletePos开始的指定数量deleteCount的元素，数组形式返回所移除的元素 数组的截取和合并 12arrayObj.slice(start, [end]); //以数组的形式返回数组的一部分，注意不包括 end 对应的元素，如果省略 end 将复制 start 之后的所有元素 arrayObj.concat([item1[, item2[, . . . [,itemN]]]]); //将多个数组（也可以是字符串，或者是数组和字符串的混合）连接为一个数组，返回连接好的新的数组 数组的拷贝 12arrayObj.slice(0); //返回数组的拷贝数组，注意是一个新的数组，不是指向arrayObj.concat(); //返回数组的拷贝数组，注意是一个新的数组，不是指向 数组元素的排序 12arrayObj.reverse(); //反转元素（最前的排到最后、最后的排到最前），返回数组地址arrayObj.sort(); //对数组元素排序，返回数组地址 数组元素的字符串化 12arrayObj.join(separator); //返回字符串，这个字符串将数组的每一个元素值连接在一起，中间用 separator 隔开。 //toLocaleString 、toString 、valueOf：可以看作是join的特殊用法，不常用 数组对象的3个属性： length 属性 Length属性表示数组的长度，即其中元素的个数。因为数组的索引总是由0开始，所以一个数组的上下限分别是：0和length-1。和其他大多数语言不同的是，ECMAScript数组的length属性是可变的，这一点需要特别注意。当length属性被设置得更大时，整个数组的状态事实上不会发生变化，仅仅是length属性变大；当length属性被设置得比原来小时，则原先数组中索引大于或等于length的元素的值全部被丢失。下面是演示改变length属性的例子： 123456789var arr=[12,23,5,3,25,98,76,54,56,76];//定义了一个包含10个数字的数组 //显示数组的长度10arr.length=12; //增大数组的长度 //显示第9个元素的值，为56arr.length=5; //将数组的长度减少到5，索引等于或超过5的元素被丢弃 //显示第9个元素已经变为\"undefined\"arr.length=10; //将数组长度恢复为10 //虽然长度被恢复为10，但第9个元素却显示\"undefined\" 由上面的代码我们可以清楚的看到length属性的性质。但length对象不仅可以显式的设置，它也有可能被隐式修改。ECMAScript中可以使用一个未声明过的变量，同样，也可以使用一个未定义的数组元素（指索引超过或等于length的元素），这时，length属性的值将被设置为所使用元素 索引的值加1。例如下面的代码：12var arr=[12,23,5,3,25,98,76,54,56,76];arr[15]=34; prototype 属性 返回对象类型原型的引用。prototype 属性是 object 共有的。 objectName.prototype objectName 参数是object对象的名称。 说明：用 prototype 属性提供对象的类的一组基本功能。 对象的新实例“继承”赋予该对象原型的操作。 对于数组对象，以以下例子说明prototype 属性的用途。 给数组对象添加返回数组中最大元素值的方法。要完成这一点，声明一个函数，将它加入 Array.prototype， 并使用它。1234567891011121314 function array_max() &#123; var i, max = this[0]; for (i = 1; i &lt; this.length; i++) &#123; if (max &lt; this[i]) max = this[i]; &#125; return max; &#125; Array.prototype.max = array_max; var x = new Array(1, 2, 3, 4, 5, 6); var y = x.max(); constructor 属性 表示创建对象的函数。 object.constructor //object是对象或函数的名称。 说明：constructor 属性是所有具有 prototype 的对象的成员。constructor 属性保存了对构造特定对象实例的函数的引用。 例如：12 x = new String(\"Hi\"); if (x.constructor == String) // 进行处理（条件为真）。 或12345 function MyFunc &#123; // 函数体。 &#125; y = new MyFunc; if (y.constructor == MyFunc)&#123;&#125; // 进行处理（条件为真）。 对于数组来说：1y = new Array(); 关于Math、Data等类型请移驾到Qt帮助模式下，以关键字检索即可！ 6.函数首先，ECMAScript不支持函数重载，然后我们再说函数语法。 函数语法如下：123 function functionName(arg1,arg2,...,argN) &#123; // 要执行的代码 &#125; function是定义函数时必须使用的关键字；小括号内arg参数可以不加；functionName可以任意取，符合变量命名规则即可；花括号内是要执行的代码块；函数要返回值时，可以用return语句； 其他的一些运算符、优先级以及循环语句和条件控制语句，这里一概不论，下面说说这个console。 7.使用consoleconsole是和实现ECMAScript的宿主环境相关的一个对象，提供了输出日志信息、断言、计时器、计数器、性能分析等功能。 前面一直使用的console.log()是用来输出调试信息的，console对象提供了多个打印调试信息的方法： console.log(); console.debug(); console.info(); console.warn(); console.error(); 这些方法是调试QML的利器，我们以console.log()为例来说明，它可以打印下列信息： 字符串 数字 数组 任意实现toString()方法的对象 示例代码片段： 1234 console.log(\"I\\'m minor,^_^\"); console.log(\"I\\'m \", 16); var array = new Array(10,12,8,\"Anna\"); console.debug(\"print array:\",array); 还有一个常用的功能就是计时器： console.time(tag)启动定时器，字符串类型的tag是必须的； console.timeEnd(tag)停止计时器； 简单示例如下：12345 console.time(\"控制台计时器一\"); for(var i=0;i&lt;1000;i++)&#123; for(var j=0;j&lt;1000;j++)&#123;&#125; &#125; console.timeEnd(\"控制台计时器一\"); 好，路还在继续，只不过本节到此结束吧！ 转载请注明博客来源：http://www.cnblogs.com/lxmwb/p/6291220.html","categories":[{"name":"Qt框架","slug":"Qt框架","permalink":"http://cnsimo.cn/categories/Qt框架/"}],"tags":[{"name":"QtQuick系列","slug":"QtQuick系列","permalink":"http://cnsimo.cn/tags/QtQuick系列/"},{"name":"QML","slug":"QML","permalink":"http://cnsimo.cn/tags/QML/"}]},{"title":"在linux中连接wifi","slug":"在linux中连接wifi","date":"2016-01-20T02:58:00.000Z","updated":"2017-02-05T09:42:26.863Z","comments":true,"path":"2016-01-20/在linux中连接wifi/","link":"","permalink":"http://cnsimo.cn/2016-01-20/在linux中连接wifi/","excerpt":"","text":"分为以下步骤：———–（键入以下命令的时候注意大小写与空格。） 1. 进入终端treminal 获取管理员权限---------------------- su 命令（# su） 2. 查看可用的无线网卡，记下Interface之后的网卡名称（我的是 wlp9s0）---------------------iw命令（# iw dev） 3. 查看 wlp9s0网卡的激活状态，尖括号&lt;&gt;内没有‘’UP‘’字样就表示未激活，若有可直接跳过第4和第5步----------------------ip命令 （# ip link show wlp9s0） 4. 激活 wlp9s0 网卡--------------------------------------ip命令 （# ip link set wlp9s0 up） 5. 再次查看网卡激活状态，若未激活，可采取的措施有重复上述操作和重启电脑再次激活---ip命令 （# ip link show wlp9s0） 6. 搜索附近可用的无线网络----------------------------iw命令 （# iw wlp9s0 scan | grep SSID） 7. 如果存在可用的无线网络，红色的‘SSID‘之后便是它的名词，我用的无线名称是 ‘’mo‘’--------wpa_supplicant命令 （# wpa_supplicant -B -i wlp9s0 -c&lt;(wpa_passphrase &quot;mo&quot; &quot;无线密码&quot;)） 8. 为此网卡分配ip地址---------------------------------dhclient命令 （# dhclient wlp9s0） 9. 少等片刻即可继续，此时查看网卡激活状态会发现 &lt;&gt;中多出了 LOWER_UP 词条，证明操作成功。 10. 最后一步是测试网络连接状态,也可以直接打开浏览器测试----------ping命令 （# ping www.baidu.com） ----- 可以与www.baidu.com建立连接后按下 ctrl+c 可以停止 ping命令 本文为 凌小墨 撰写 ，转发请注明作者，本文链接：http://www.cnblogs.com/lxmwb/p/5144363.html","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cnsimo.cn/categories/Linux/"}],"tags":[]},{"title":"淡说Linux的发展史","slug":"淡说Linux的发展史","date":"2015-11-10T09:07:00.000Z","updated":"2017-02-05T09:39:27.686Z","comments":true,"path":"2015-11-10/淡说Linux的发展史/","link":"","permalink":"http://cnsimo.cn/2015-11-10/淡说Linux的发展史/","excerpt":"1 Linux的简单介绍 Linux与Windows一样都是一套OS（操作系统），Windows界面美观 ，普通用户很容易上手，点点鼠标就能搞定许多操作，而Linux生下来就是为程序员的，故精通Linux都是非常擅长命令行的，可以说命令行就是学习Linux的最基础的东西了，操作相对Windows来说并不是那么的容易上手，反而很复杂，因为命令行是艰涩难懂的，故造成了如今Linux只在程序员中流行，而普通电脑用户可能根本不知道它的存在，我当初也是听说的，到现在我才有极度想要学习它的念头，好了，废话不多说。","text":"1 Linux的简单介绍 Linux与Windows一样都是一套OS（操作系统），Windows界面美观 ，普通用户很容易上手，点点鼠标就能搞定许多操作，而Linux生下来就是为程序员的，故精通Linux都是非常擅长命令行的，可以说命令行就是学习Linux的最基础的东西了，操作相对Windows来说并不是那么的容易上手，反而很复杂，因为命令行是艰涩难懂的，故造成了如今Linux只在程序员中流行，而普通电脑用户可能根本不知道它的存在，我当初也是听说的，到现在我才有极度想要学习它的念头，好了，废话不多说。操作系统=内核（kernel）+系统调用接口，内核与硬件紧密相关，见图1.1，仅有内核的话，只能将计算机运行起来，而你什么都不能做，干瞪眼的干活，所以说操作系统除了内核外 系统调用接口也是相当的重要的，有了它们，软件开发者就可以利用这些接口开发出软件，软件让操作系统更加的完美。 1.1 Torvalds先生在写出Linux的时候，这个OS也仅有内核与接口这么简单，而且还是针对386来开发的，所以也仅能“让计算机开始运行，等待用户输入指令”而已，事实上，能在Linux上跑的软件还很少呢。 每种OS都是在它专门的机器上运行的，像Windows系统是专门针对个人计算进X86架构的硬件去设计的，有人问 Windows操作系统能装在 苹果公司的麦金塔计算机（MAC） 上面吗？ 结果很明显 不可以啊 ，为什么呢，由上可知硬件是由内核来控制的，Windows操作系统的内核只能控制Intel的X86架构的硬件，而06年之前苹果公司是请IBM公司开发硬件（所谓的power CPU）， 然后apple在该硬件架构上开发自家的OS（即Mac），故Windows是不能安装在苹果计算机上的。但是在06年之后苹果公司也采用了Intel的X86架构的硬件，此时才可能将Windows用于Mac计算机，注意了，仅仅是可能，据说是由于兼容性问题的存在，这里我也不太明白。再说Linux吧，这个系统是一个Open Source（开放源代码）的操作系统，这就注定了它具有“可移植”这个强大的优点，理论上讲Linux的源代码可以被修改从而在各种机器上运行，Windows闭源则不行啊，这就奠定了Linux的良好前途。 Linux是一个提供了一个完整操作系统当中最底层的硬件控制与资源管理的完整架构，这个架构是沿袭Unix良好的传统而来的，所以相当稳定并且强大。 如此越来越多的软件开发者渐渐将工作心血转移到了这个系统上，所以之后能在Linux上运行的软件也不在少数了。这些软件与Linux共同形成了一个更加强大，更加稳定的操作系统发展至今。 2.至于Linux追根溯源到底是如何来的，那就要从Unix说起了，先说说跟Unix的建立有关的东西吧。2.1 1969年以前——Multics项目 在20世纪60年代左右一间学校可能仅有一台主机，而如此多的学生免不了要等待才能使用，好在之后麻省理工学院（MIT）开发了分时操作系统（compatible time-sharing system，CTSS），它可以让多个终端机通过连接大型主机利用主机的资源进行运算工作，其架构如图2.1 2.1 这些终端机只能提供输入输出的功能，本身并不能安装软件或运算的能力，而且最先进的主机只能让30多台终端机连入而已。为了加强大型主机的功能，以便让更多的用户利用主机的资源，所以在1965年前后，由贝尔实验室（Bell）、麻省理工学院（MIT）及通用电气公司（GE）共同发起了Multics的项目，Multics的最终目标是让一台大型主机可以同时接入300台以上的终端机。但是后来由于资金短缺进度落后等原因，这个项目最终没有获得成就，而贝尔实验室也退出了该项目的研究。 虽然这个项目不成功，但是这个项目培养出了的人才是相当优秀的。 2.2 1969年——Ken Thompson的小型File Server System Ken Thompson是 参与Multics项目的贝尔实验室人员之一，他从Multics中获得了一点想法，他用了四个星期的时间，终于以汇编语言（Assembier）写出了一组内核程序，同时包括一些内核工具程序，以及一个小的文件系统。该系统就是UNIX的原型，被同事们戏称为Unics。只能说“科技来自于人性”。 2.3 1973年——Unix正式诞生，Ritchie等人以C语言写出第一个正式UNIX内核 由于Thompson写的那个OS太好用了，所以在贝尔实验室内部广为流传，并且多次经过改版。 但是因为Unics使用汇编语言写出来的，汇编语言的专一性，所以若计算机的架构不同的话，每次安装都得进行重新编写这个步骤，灰常的不方便。 当时现成的高级语言有B语言，但是有B语言编译出来的内核性能不是很好，于是Dennis Ritchie将B语言重新改写成了C语言，Thompson、Ritchies两人合作用C语言重新编写UNICS的内核，最后发行出Unix的正式版本！！到这里你会发现，哦，C语言原来是这么来的啊，还真是神奇呢。C语言使得Unix很容易被移植到不同的机器上。 2.4 1977年——重要的Unix分支-BSD的诞生 柏克莱大学的Bill Joy在取得了UNIX的内核源码后，便着手于修改适合自己机器的版本，并且同时增加了很多工具软件和编译程序看，最终将它命名为Berkeley Software Distribution（BSD）。这个BSD是UNIX的一个很重要的分支，Bill Joy也是Sun这家公司的创始人。 2.5 1979年：重要的System V架构与版权声明 早期的UNIX只能跟服务器（SERVER）和大型工作站（Workstation）画上等号！直到AT&amp;T公司推出System V后才有所改观，S V这个架构最特殊的地方就是支持X86架构的个人计算机系统，也就是说它可以安装在个人计算机上并运行。 不过，AT&amp;T出于对商业的考虑，以及在当时现实环境下的思考，于是想将UNIX的版权收回去。因此，AT&amp;T在1979年发行的第七版UNIX中，声明“不可对学生提供源码”，这个事件也造成了UNIX业界之间的紧张气氛，并且引发了很多商业纠纷。 注：目前被称为纯种的UNIX指的就是System V 和 BSD这两套。 2.6 1984年：X86架构的Minux操作系统诞生 由于1979年的版权声明，影响到了教授关于UNIX的教学，无法向学生提供UNIX源码，教授没法讲解，谭宁邦教授就是其中之一，他自己动手编写了一个能在X86上运行的UNIX Like的内核程序Minix，为了避免版权纠纷，谭宁邦教授在编写过程中完全不看UNIX内核源码，并且强调Minix必须与UNIX兼容才行，直到1986年终于完成。 Minix操作系统的开发者只有谭宁邦教授一人，因为学术很忙，而且谭宁邦始终认为Minix主要用在教育上面，所以对Minix是点到为止。Minix虽然很受欢迎，但是它已无法再向更高的位置前进了。 2.7 1984年：GUN项目与FSF基金会成立 这两个东西的成立者都是史托曼（英文名：Richard Mathew Stallman，RMS），GUN项目创建的目的是创建一个自由、开放的UNIX操作系统（Free UNIX），他一个人是无法完成的，所以他以出售他自己编写的那个Emacs来赚钱，Emacs是一个很好很优秀的程序编辑器，非常牛，赚了点钱后全力编写其他软件，并且成立了自由软件基金会（Free Software Foundation，FSF），请来了更多的工程师和志愿者一同编写软件，写出了GCC这个比Emacs更加优秀的工具，还有更多可以被调用的C函数库（GNU C Library），以及可以被用来操作系统的基本接口bash shell，大约在1990年完工。 3.Torvalds的Linux开发 GUN、GCC、minux等等这些东西的出现都为托瓦兹开发Linux打下基石，利用这些东西，托瓦兹写出了自己的操作系统，当这个内核程序可以在386上顺利运行后，他希望能够获取大家的意见，于是将这个内核放到网上供大家下载。。。。。。之后各个Linux团队产生，到现在各大distributions横行这个过程我就自动省略了。 4.再稍微普及点知识吧。4.1 主次版本为基数：开发中版本（development） 如2.5.xx，这种内核主要用于测试和开发新功能，经众多工程师测试没问题后，才加入下一版的稳定内核中。 4.2 主次版本为偶数：稳定版本（stable） 如2.6.xx，这种版本可以提供给用户使用了。 想学的话建议CentOS为入门系统。说到这里，此篇文章到此结束。 本文为 凌小墨 撰写 ，转发请勿清除此行，本文链接：http://www.cnblogs.com/lxmwb/p/5144363.html","categories":[{"name":"Linux","slug":"Linux","permalink":"http://cnsimo.cn/categories/Linux/"}],"tags":[]}]}